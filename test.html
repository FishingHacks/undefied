<!DOCTYPE html><html lang="en"><head><title>Undefied Javascript Runtime</title></head><body><script>globalThis.devmode = false;

// ExitError
class ExitError extends Error {exitCode;constructor(exitcode, message) {super(message);this.exitCode = exitcode;}}
globalThis.ExitError = ExitError;

// Console Environment Setup
(() => {
    // NODE UTILS START

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    //#region utilcode
    var formatRegExp = /%[sdj%]/g;
    function format(f) {
        if (!isString(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
                if (typeof arguments[i] === 'object') {
                    objects.push(inspect(arguments[i]));
                } else objects.push(arguments[i].toString());
            }
            return objects.join(' ');
        }

        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function (x) {
            if (x === '%%') return '%';
            if (i >= len) return x;
            switch (x) {
                case '%s':
                    return String(args[i++]);
                case '%d':
                    return Number(args[i++]);
                case '%j':
                    try {
                        return JSON.stringify(args[i++]);
                    } catch (_) {
                        return '[Circular]';
                    }
                default:
                    return x;
            }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
            } else {
                str += ' ' + inspect(x);
            }
        }
        return str;
    }
    function inspect(obj) {
        // default options
        var ctx = {
            seen: [],
            stylize: stylizeWithColor,
            depth: 10,
            colors: true,
            showHidden: false,
        };
        return formatValue(ctx, obj, ctx.depth);
    }
    inspect.colors = {
        bold: [1, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        white: [37, 39],
        grey: [90, 39],
        black: [30, 39],
        blue: [34, 39],
        cyan: [36, 39],
        green: [32, 39],
        magenta: [35, 39],
        red: [31, 39],
        yellow: [33, 39],
    };
    inspect.styles = {
        special: 'cyan',
        number: 'yellow',
        boolean: 'yellow',
        undefined: 'grey',
        null: 'bold',
        string: 'green',
        date: 'magenta',
        // "name": intentionally not styling
        regexp: 'red',
    };
    function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];

        if (style) {
            return (
                '\u001b[' +
                inspect.colors[style][0] +
                'm' +
                str +
                '\u001b[' +
                inspect.colors[style][1] +
                'm'
            );
        } else {
            return str;
        }
    }
    function arrayToHash(array) {
        var hash = {};

        array.forEach(function (val, idx) {
            hash[val] = true;
        });

        return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
        // Primitive types cannot have properties
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
            return primitive;
        }

        // Look up the keys of the object.
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);

        if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
        }

        // IE doesn't make error fields non-enumerable
        // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
        if (
            isError(value) &&
            (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)
        ) {
            return formatError(value);
        }

        // Some type of object without properties can be shortcutted.
        if (keys.length === 0) {
            if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
            }
            if (isRegExp(value)) {
                return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    'regexp'
                );
            }
            if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
            }
            if (isError(value)) {
                return formatError(value);
            }
        }

        var base = '',
            array = false,
            braces = ['{', '}'];

        // Make Array say that they are Array
        if (isArray(value)) {
            array = true;
            braces = ['[', ']'];
        }

        // Make functions say that they are functions
        if (isFunction(value)) {
            var n = value.name ? ': ' + value.name : '';
            base = ' [Function' + n + ']';
        }

        // Make RegExps say that they are RegExps
        if (isRegExp(value)) {
            base = ' ' + RegExp.prototype.toString.call(value);
        }

        // Make dates with properties first say the date
        if (isDate(value)) {
            base = ' ' + Date.prototype.toUTCString.call(value);
        }

        // Make error with message first say the error
        if (isError(value)) {
            base = ' ' + formatError(value);
        }

        if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
        }

        if (recurseTimes < 0) {
            if (isRegExp(value)) {
                return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    'regexp'
                );
            } else {
                return ctx.stylize('[Object]', 'special');
            }
        }

        ctx.seen.push(value);

        var output;
        if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
            output = keys.map(function (key) {
                return formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    array
                );
            });
        }

        ctx.seen.pop();

        return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
        if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
        if (isString(value)) {
            var simple =
                "'" +
                JSON.stringify(value)
                    .replace(/^"|"$/g, '')
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"') +
                "'";
            return ctx.stylize(simple, 'string');
        }
        if (isNumber(value)) return ctx.stylize('' + value, 'number');
        if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
        // For some reason typeof null is "object", so special case here.
        if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
            if (Object.prototype.hasOwnProperty.call(value, String(i))) {
                output.push(
                    formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        String(i),
                        true
                    )
                );
            } else {
                output.push('');
            }
        }
        keys.forEach(function (key) {
            if (!key.match(/^\d+$/)) {
                output.push(
                    formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        key,
                        true
                    )
                );
            }
        });
        return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || {
            value: value[key],
        };
        if (desc.get) {
            if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
            } else {
                str = ctx.stylize('[Getter]', 'special');
            }
        } else {
            if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
            }
        }
        if (!Object.prototype.hasOwnProperty.call(visibleKeys, key)) {
            name = '[' + key + ']';
        }
        if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                    str = formatValue(ctx, desc.value, null);
                } else {
                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf('\n') > -1) {
                    if (array) {
                        str = str
                            .split('\n')
                            .map(function (line) {
                                return '  ' + line;
                            })
                            .join('\n')
                            .slice(2);
                    } else {
                        str =
                            '\n' +
                            str
                                .split('\n')
                                .map(function (line) {
                                    return '   ' + line;
                                })
                                .join('\n');
                    }
                }
            } else {
                str = ctx.stylize('[Circular]', 'special');
            }
        }
        if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
                return str;
            }
            name = JSON.stringify('' + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.slice(1, -1);
                name = ctx.stylize(name, 'name');
            } else {
                name = name
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')
                    .replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
            }
        }

        return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function (prev, cur) {
            numLinesEst++;
            if (cur.indexOf('\n') >= 0) numLinesEst++;
            return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);

        if (length > 60) {
            return (
                braces[0] +
                (base === '' ? '' : base + '\n ') +
                ' ' +
                output.join(',\n  ') +
                ' ' +
                braces[1]
            );
        }

        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    function isArray(ar) {
        return Array.isArray(ar);
    }
    function isBoolean(arg) {
        return typeof arg === 'boolean';
    }
    function isNull(arg) {
        return arg === null;
    }
    function isNumber(arg) {
        return typeof arg === 'number';
    }
    function isString(arg) {
        return typeof arg === 'string';
    }
    function isUndefined(arg) {
        return arg === void 0;
    }
    function isRegExp(re) {
        return (
            isObject(re) &&
            Object.prototype.toString.call(re) === '[object RegExp]'
        );
    }
    function isObject(arg) {
        return typeof arg === 'object' && arg !== null;
    }
    function isDate(d) {
        return (
            isObject(d) && Object.prototype.toString.call(d) === '[object Date]'
        );
    }
    function isError(e) {
        return (
            isObject(e) &&
            (Object.prototype.toString.call(e) === '[object Error]' ||
                e instanceof Error)
        );
    }
    function isFunction(arg) {
        return typeof arg === 'function';
    }
    function _extend(origin, add) {
        // Don't do anything if add isn't an object
        if (!add || !isObject(add)) return origin;

        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
            origin[keys[i]] = add[keys[i]];
        }
        return origin;
    }
    // #endregion
    // NODE UTILS END

    function highlight(
        text,
        currentForeground,
        currentBackground,
        italic,
        underline,
        strikethrough,
        bold,
        lastElement
    ) {
        const elements = [];

        const split = text.split('\033[');
        if (split[0].length > 0) lastElement.textContent += split[0];

        for (let i = 1; i < split.length; i++) {
            const currentSplit = split[i];
            const styler = currentSplit.substring(0, currentSplit.indexOf('m'));
            const text = currentSplit.substring(currentSplit.indexOf('m') + 1);

            if (styler.startsWith('38')) {
                const [_38, _2, r, g, b] = styler.split(';');
                if (r && g && b) {
                    currentForeground =
                        '#' +
                        [r, g, b]
                            .map((el) =>
                                Number(el).toString(16).substring(0, 2)
                            )
                            .map((el) => (el.length === 1 ? ' ' + el : ''))
                            .join('');
                }
            } else if (styler.startsWith('48')) {
                const [_38, _2, r, g, b] = styler.split(';');
                if (r && g && b) {
                    currentBackground =
                        '#' +
                        [r, g, b]
                            .map((el) =>
                                Number(el).toString(16).substring(0, 2)
                            )
                            .map((el) => (el.length === 1 ? ' ' + el : ''))
                            .join('');
                }
            } else if (styler === '39') currentForeground = 'darkgray'; // RESET
            else if (styler === '30') currentForeground = 'black';
            else if (styler === '34') currentForeground = 'dodgerblue';
            else if (styler === '36') currentForeground = 'darkcyan';
            else if (styler === '90') currentForeground = 'gray';
            else if (styler === '32') currentForeground = 'darkgreen';
            else if (styler === '35') currentForeground = 'darkmagenta';
            else if (styler === '31') currentForeground = 'darkred';
            else if (styler === '37') currentForeground = 'darkgray';
            else if (styler === '33') currentForeground = '#ca8a04';
            else if (styler === '94') currentForeground = 'lightskyblue';
            else if (styler === '96') currentForeground = 'cyan';
            else if (styler === '92') currentForeground = 'green';
            else if (styler === '95') currentForeground = 'magenta';
            else if (styler === '91') currentForeground = 'red';
            else if (styler === '97') currentForeground = 'lightgray';
            else if (styler === '93') currentBackground = '#facc15';
            // background
            else if (styler === '49') currentBackground = '#171717'; // RESET
            else if (styler === '40') currentBackground = '#171717';
            else if (styler === '44') currentBackground = 'dodgerblue';
            else if (styler === '46') currentBackground = 'darkcyan';
            else if (styler === '100') currentBackground = 'gray';
            else if (styler === '42') currentBackground = 'darkgreen';
            else if (styler === '45') currentBackground = 'darkmagenta';
            else if (styler === '41') currentBackground = 'darkred';
            else if (styler === '47') currentBackground = 'darkgray';
            else if (styler === '43') currentBackground = '#ca804';
            else if (styler === '104') currentBackground = 'lightskyblue';
            else if (styler === '106') currentBackground = 'cyan';
            else if (styler === '102') currentBackground = 'green';
            else if (styler === '105') currentBackground = 'magenta';
            else if (styler === '101') currentBackground = 'red';
            else if (styler === '107') currentBackground = 'lightgray';
            else if (styler === '103') currentBackground = '#facc15';
            // text style
            else if (styler === '22') bold = false; // RESET
            else if (styler === '23') italic = false; // RESET
            else if (styler === '29') strikethrough = false; // RESET
            else if (styler === '24') underline = false; // RESET
            else if (styler === '3') italic = true;
            else if (styler === '1') bold = true;
            else if (styler === '9') {
                underline = false;
                strikethrough = true;
            } else if (styler === '4') {
                underline = true;
                strikethrough = false;
            }
            const span = document.createElement('span');
            span.style.color = currentForeground;
            span.style.backgroundColor = currentBackground;
            span.style.fontStyle = italic ? 'italic' : 'normal';
            span.style.textDecoration = strikethrough
                ? 'line-through'
                : underline
                ? 'underline'
                : 'none';
            span.style.fontWeight = bold ? 'bold' : 'normal';
            span.textContent = text;
            elements.push(span);
        }

        return {
            currentBackground,
            currentForeground,
            italic,
            strikethrough,
            bold,
            underline,
            elements,
        };
    }

    function generateTabs() {
        const tabs = document.createElement('div');
        tabs.style.width = '100vw';
        tabs.style.overflow = 'hidden';
        tabs.style.height = '2rem';
        tabs.style.display = 'flex';
        tabs.style.flexWrap = 'nowrap';
        tabs.style.flexDirection = 'row';
        tabs.style.backgroundColor = '#171717';

        const consoleTab = document.createElement('div');
        const canvasTab = document.createElement('div');

        consoleTab.style.width = '50vw';
        consoleTab.style.textAlign = 'center';
        consoleTab.style.backgroundColor = '#171717';
        consoleTab.style.color = 'darkgray';
        consoleTab.style.fontWeight = '900';
        consoleTab.style.fontSize = '1.5rem';
        consoleTab.style.fontFamily = 'sans-serif';
        consoleTab.style.height = '2rem';
        consoleTab.style.cursor = 'pointer';
        consoleTab.style.userSelect = 'none';
        consoleTab.style.borderBottom = '#171717 3px solid';
        consoleTab.style.boxSizing = 'border-box';
        consoleTab.style.transition = 'border-bottom .25s ease';
        consoleTab.textContent = 'Console';
        tabs.append(consoleTab);

        canvasTab.style.width = '50vw';
        canvasTab.style.textAlign = 'center';
        canvasTab.style.backgroundColor = '#171717';
        canvasTab.style.color = 'darkgray';
        canvasTab.style.fontWeight = '900';
        canvasTab.style.fontSize = '1.5rem';
        canvasTab.style.fontFamily = 'sans-serif';
        canvasTab.style.height = '2rem';
        canvasTab.style.cursor = 'pointer';
        canvasTab.style.userSelect = 'none';
        canvasTab.style.borderBottom = '#171717 3px solid';
        canvasTab.style.boxSizing = 'border-box';
        canvasTab.style.transition = 'border .25s ease';
        canvasTab.textContent = 'Canvas';
        tabs.append(canvasTab);

        function change(selected) {
            if (selected === 'console') {
                consoleTab.style.borderBottom = 'yellow 3px solid';
                canvasTab.style.borderBottom = '#171717 3px solid';
                [...document.getElementsByClassName('console')].forEach(
                    (el) => (el.style.display = 'block')
                );
                [...document.getElementsByClassName('canvas')].forEach(
                    (el) => (el.style.display = 'none')
                );
            } else {
                canvasTab.style.borderBottom = 'yellow 3px solid';
                consoleTab.style.borderBottom = '#171717 3px solid';
                [...document.getElementsByClassName('console')].forEach(
                    (el) => (el.style.display = 'none')
                );
                [...document.getElementsByClassName('canvas')].forEach(
                    (el) => (el.style.display = 'block')
                );
            }
        }

        canvasTab.addEventListener('click', () => change('canvas'));
        consoleTab.addEventListener('click', () => change('console'));
        change('console');
        return tabs;
    }

    document.body.style.margin = '0px';
    document.body.style.padding = '0px';
    document.body.style.overflowX = 'hidden';
    document.body.style.overflowY = 'hidden';

    function generateFancyness(element) {
        const heading = document.createElement('span');
        heading.textContent = 'Console\n';
        heading.style.fontWeight = 'bold';
        heading.style.fontSize = '1.5rem';
        element.append(heading);
        const elements = [
            document.createElement('span'),
            document.createElement('span'),
            document.createElement('span'),
            document.createElement('span'),
        ];
        elements[0].style.fontWeight = 'bold';
        elements[1].style.fontWeight = 'bold';
        elements[3].style.textDecoration = 'underlined';
        elements[1].style.color = 'lightskyblue';
        elements[3].style.color = 'lightskyblue';
        elements[0].style.color = 'green';
        elements[2].style.color = 'dodgerblue';
        elements[0].textContent = 'root@linux ';
        elements[1].textContent = '~/undefied $ ';
        elements[2].textContent = './run.sh ';
        elements[3].textContent = './undefiedProgram.js\n';
        element.append(...elements);
    }

    const canvas = document.createElement('canvas');
    globalThis.canvas = canvas;
    canvas.style.width = '100vw';
    canvas.style.height = window.logToConsole ? '100vh' : 'calc(100vh - 2rem)';
    canvas.classList.add('canvas');
    canvas.style.backgroundColor = '#222';

    document.body.append(canvas);
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    let unused = document.createElement('p');
    unused.style.color = 'orange';
    unused.style.fontWeight = 'bold';
    unused.textContent = 'Warn: Canvas is unused';
    unused.classList.add('canvas-unused', 'canvas');
    unused.style.position = 'absolute';
    unused.style.top = '50%';
    unused.style.left = '50%';
    unused.style.transform = 'translate(-50%, -50%)';
    unused.style.margin = '0px';
    unused.style.padding = '0px';

    document.body.append(unused);

    const oldCanvasGetCtx = canvas.getContext;
    canvas.getContext = function getContext(...args) {
        unused?.remove();
        unused = undefined;
        return oldCanvasGetCtx.apply(canvas, args);
    }

    let element = document.getElementsByClassName('console')[0];
    if (!element && !window.logToConsole) {
        element = document.createElement('pre');
        element.classList.add('console');
        element.style.backgroundColor = '#171717';
        element.style.padding = '.5rem';
        element.style.color = 'darkgray';
        element.style.width = 'calc(100vw - 1rem)';
        element.style.height = 'calc(100vh - 3rem)';
        element.style.margin = '0px';
        element.style.overflowX = 'hidden';
        element.style.overflowY = 'scroll';
        element.style.whiteSpace = 'pre-wrap';
        element.style.wordBreak = 'break-word';
        generateFancyness(element);
        document.body.append(element);
    }
    if (!window.logToConsole)
        document.body.insertBefore(generateTabs(), canvas);
    let styles = {
        fg: 'darkgray',
        bg: '#171717',
        italic: false,
        underline: false,
        strikethrough: false,
        bold: false,
    };
    if (!window.logToConsole) {
        let lastElement = undefined;

        // const oldlog = console.log;
        console.log = function log(...args) {
            // oldlog(...args);
            if (!lastElement) {
                lastElement = document.createElement('span');
                lastElement.style.color = styles.fg;
                lastElement.style.backgroundColor = styles.bg;
                lastElement.style.fontStyle = styles.italic
                    ? 'italic'
                    : 'normal';
                lastElement.style.textDecoration = styles.strikethrough
                    ? 'line-through'
                    : styles.underline
                    ? 'underline'
                    : 'none';
                lastElement.style.fontWeight = styles.bold ? 'bold' : 'normal';
                element.append(lastElement);
            }
            const str = format(...args);
            const newStyles = highlight(
                str,
                styles.fg,
                styles.bg,
                styles.italic,
                styles.underline,
                styles.strikethrough,
                styles.bold,
                lastElement
            );
            styles.bg = newStyles.currentBackground;
            styles.fg = newStyles.currentForeground;
            styles.bold = newStyles.bold;
            styles.italic = newStyles.italic;
            styles.strikethrough = newStyles.strikethrough;
            styles.underline = newStyles.underline;
            if (newStyles.elements.length > 0) {
                element.append(
                    ...newStyles.elements
                        .slice(0, newStyles.elements.length - 1)
                        .filter((el) => el.textContent.length > 0),
                    newStyles.elements[newStyles.elements.length - 1]
                );
                lastElement = newStyles.elements[newStyles.elements.length - 1];
            }
            element.scrollTo({
                top: element.scrollHeight,
                behavior: window.hardScroll ? 'instant' : 'smooth',
            });
        };
        console.error = console.log;
        console.clear = function clear() {
            lastElement = undefined;
            [...element.children].slice(5).forEach((el) => el.remove());
        };
        console.assert = function assert(condition, ...args) {
            if (args.length < 1) args.push('console.assert');
            if (!condition)
                console.error(
                    '\033[31m\033[1mAssertion Failed: %s\033[39m\033[22m',
                    ...args
                );
        };

        const counter = {};
        console.count = function count(label) {
            if (label === undefined) label = 'default';
            if (typeof label !== 'string') label = label.toString();
            counter[label] ||= 0;
            console.log(label + ': ' + counter[label]++ + '\n');
        };
        console.countReset = function countReset(label) {
            if (label === undefined) label = 'default';
            if (typeof label !== 'string') label = label.toString();
            delete counter[label];
        };
        console.debug = function debug(...args) {
            if (args.length < 1) return;
            console.log('\033[34m%s\033[39m', ...args);
        };
        console.dir = console.log;
    }
})();


// Syscall Support
(function () {
    const exitError = globalThis.ExitError;

    function SC_exit(int) {
        throw new exitError(int);
    }

    const arr = [SC_exit];
    for (const el of arr) globalThis[el.name] = el;
})();


// Compiled Data
globalThis.exports={};globalThis.__undefieddata__ = {"operations":[{"type":7},{"type":7},{"type":3,"operation":5},{"type":7},{"type":4},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":7},{"type":3,"operation":450},{"type":7},{"type":8,"length":9,"ptr":1},{"type":7},{"type":2,"operation":1},{"type":5,"operation":3,"functionName":"fputs","externalCall":true,"ins":3,"outs":0},{"type":7},{"type":4}],"exports":[],"memories":{},"memory":[0,72,101,119,119,111,32,58,51,10],"run":[],"mainop":443};

// Util functions for javascript
(function () {
    const utils = (globalThis.undefiedutils = {});
    const memory = __undefieddata__.memory;
    const isNode = globalThis.process !== undefined;

    utils.readMemory = function readMemory(offset, length) {
        return memory.slice(offset, offset + length);
    };

    utils.writeMemory = function writeMemory(offset, length, data) {
        if (data.length !== length)
            throw new Error('The data array length has to be equal to length');
        for (let i = 0; i < length; i++) memory[offset + i] = data[i];
    };

    utils.free = function free(ptr) {
        const size = memory[ptr - 1];
        for (let i = 0; i < size; i++) delete memory[memory.length - 1 - i];
    };

    utils.malloc = function malloc(sz) {
        if (sz === 0) return -1;
        memory[memory.length] = sz + 1;
        const ptr = memory.length;
        for (let i = 0; i < sz; i++) memory[ptr + i] = 0;
        return ptr;
    };

    utils.toUndefiedStr = function toUndefiedStr(str) {
        const ptr = malloc(str.length);
        utils.writeMemory(
            ptr,
            str.length,
            Object.values(str).map((el) => el.charCodeAt(0))
        );
        return [str.length, ptr];
    };

    utils.panic = function panic(str) {
        console.log('\x1B[31m%s\x1B[39m', str);
        throw new window.ExitError(1);
    };

    utils.color_r = function r(color = 0) {
        return Number((BigInt(color) & 4278190080n) >> 24n);
    };
    utils.color_g = function g(color = 0) {
        return Number((BigInt(color) & 16711680n) >> 16n);
    };
    utils.color_b = function b(color = 0) {
        return Number((BigInt(color) & 65280n) >> 8n);
    };
    utils.color_a = function a(color = 0) {
        return Number(BigInt(color) & 255n); // extract the first byte of the 4-byte color
    };
    utils.rgbaToRgbaArray = function rgbaToRgbaArray(color = 0) {
        return [utils.color_r(color), utils.color_g(color), utils.color_b(color), utils.color_a(color)];
    };
    utils.rgba = function rgba(r = 0, g = 0, b = 0, a = 0) {
        if (r > 255) r = 255;
        if (r < 0) r = 0;
        if (g > 255) g = 255;
        if (g < 0) g = 0;
        if (b > 255) b = 255;
        if (b < 0) b = 0;
        if (a > 255) a = 255;
        if (a < 0) a = 0;
        return (
            (BigInt(r) << 24n) |
            (BigInt(g) << 16n) |
            (BigInt(b) << 8n) |
            BigInt(a)
        );
    };
})();

// Util functions for undefied

(function () {
    function exportFn(fn, name) {
        name ||= fn.name;
        if (globalThis[name] !== undefined)
            throw new Error('globalThis.' + name + ' is already defined!');
        globalThis[name] = fn;
    }

    const utils = globalThis.undefiedutils;
    const memory = __undefieddata__.memory;
    const isNode = globalThis.process !== undefined;

    const requestFrame =
        globalThis.requestAnimationFrame ||
        ((fn) => globalThis.setTimeout(fn, 1));
    let input = isNode ? () => 'input is not yet setup' : prompt;
    if (isNode) {
        const util = require('util');
        const readline = require('readline/promises');
        console.log = function log(...args) {
            process.stdout.write(util.format(...args));
        };
        console.error = function error(...args) {
            process.stderr.write(util.format(...args));
        };
        input = async function prompt(text = '') {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
            const result = await rl.question(
                text.length > 0 ? text + ': ' : ''
            );
            rl.close();
            return result;
        };
    }

    let changes = 0;
    globalThis.bufferLength ||= 10;

    function toString(ptr, length) {
        return String.fromCharCode(...utils.readMemory(ptr, length));
    }

    function malloc(sz) {
        return utils.malloc(sz);
    }

    function free(sz) {
        return utils.free(sz);
    }

    let buffer = '';

    function fputs(fd, ptr, length) {
        changes++;
        if (fd !== 2 && fd !== 1)
            throw new Error(
                'fputs called with a file descriptor other than 1 or 2 (' +
                    fd +
                    ')'
            );
        buffer += toString(ptr, length);
        if (changes > globalThis.bufferLength) {
            changes = 0;
            if (buffer.length > 0) console.log(buffer);
            buffer = '';
            return new Promise((r) => requestFrame(() => r()));
        }
    }

    function fromJSString(str) {
        return utils.toUndefiedStr(str);
    }
    function fromJSStringCstr(str) {
        return utils.toUndefiedStr(
            str.endsWith('\x00') ? str : str + '\x00'
        )[1];
    }

    async function readLine() {
        changes = 0;
        if (buffer.length > 0) console.log(buffer);
        buffer = '';
        await new Promise((r) => requestFrame(r));
        const str = (await input()) || '';
        return fromJSString(str);
    }

    async function readPrompt(ptr, length) {
        changes = 0;
        if (buffer.length > 0) console.log(buffer);
        buffer = '';
        await new Promise((r) => requestFrame(r));
        const str = (await input(toString(ptr, length))) || '';
        return fromJSString(str);
    }
    function awaitNextRender() {
        changes = 0;
        if (buffer.length > 0) console.log(buffer);
        buffer = '';
        return new Promise((r) => requestFrame(() => r()));
    }
    function sleep(time) {
        return new Promise((r) => setTimeout(() => r(), time));
    }
    function random(int) {
        return Math.floor(Math.random() * (int + 1));
    }

    // CANVAS STUFF
    let ctx;

    function canvasInitialize(w, h) {
        canvas.width = w;
        canvas.height = h;
        ctx = canvas.getContext('2d');
    }

    function useCtx() {
        if (!ctx)
            utils.panic(
                'The Canvas is not yet set up (Call Canvas::Initalize with width and height)'
            );
    }

    function putCanvas(ptr, w, h) {
        useCtx();
        if (w > canvas.width)
            utils.panic(
                'The specified width is greather than the canvas width!'
            );
        if (h > canvas.height)
            utils.panic(
                'The specified height is greather than the canvas height!'
            );
        const array = memory.slice(ptr, ptr + w * h);
        if (array.length !== w * h)
            utils.panic('The Array is not properly set up');
        const buf = new Uint8ClampedArray(array.length * 4);
        for (let i = 0; i < array.length; i++) {
            const [r, g, b, a] = utils.rgbaToRgbaArray(memory[ptr+i]);
            buf[i * 4 + 0] = r;
            buf[i * 4 + 1] = g;
            buf[i * 4 + 2] = b;
            buf[i * 4 + 3] = a;
        }

        ctx.putImageData(new ImageData(buf, w), 0, 0);
    }

    function getSize() {
        return [globalThis.canvas.width, globalThis.canvas.height];
    }
    function getWidth() {
        return globalThis.canvas.width;
    }
    function getHeight() {
        return globalThis.canvas.height;
    }

    exportFn(toString, 'Str::toJSString');
    exportFn(free);
    exportFn(malloc);
    exportFn(fputs);
    exportFn(fromJSString, 'Str::fromJSString');
    exportFn(fromJSStringCstr, 'CStr::fromJSString');
    exportFn(readPrompt);
    exportFn(readLine);
    exportFn(awaitNextRender);
    exportFn(sleep);
    exportFn(random);
    exportFn(getSize);
    exportFn(getWidth);
    exportFn(getHeight);
    exportFn(canvasInitialize, 'Canvas::Initialize');
    exportFn(putCanvas, 'Canvas::PutData');
})();






// Interpreter

function runUndefiedCode() {"use strict";
var Intrinsic;
(function (Intrinsic) {
    Intrinsic[Intrinsic["Print"] = 0] = "Print";
    Intrinsic[Intrinsic["Plus"] = 1] = "Plus";
    Intrinsic[Intrinsic["Minus"] = 2] = "Minus";
    Intrinsic[Intrinsic["Multiply"] = 3] = "Multiply";
    Intrinsic[Intrinsic["DivMod"] = 4] = "DivMod";
    Intrinsic[Intrinsic["LessThan"] = 5] = "LessThan";
    Intrinsic[Intrinsic["LessThanEqual"] = 6] = "LessThanEqual";
    Intrinsic[Intrinsic["GreaterThan"] = 7] = "GreaterThan";
    Intrinsic[Intrinsic["GreaterThanEqual"] = 8] = "GreaterThanEqual";
    Intrinsic[Intrinsic["Equal"] = 9] = "Equal";
    Intrinsic[Intrinsic["NotEqual"] = 10] = "NotEqual";
    Intrinsic[Intrinsic["Drop"] = 11] = "Drop";
    Intrinsic[Intrinsic["Dup"] = 12] = "Dup";
    Intrinsic[Intrinsic["Over"] = 13] = "Over";
    Intrinsic[Intrinsic["Swap"] = 14] = "Swap";
    Intrinsic[Intrinsic["Rot"] = 15] = "Rot";
    Intrinsic[Intrinsic["Load"] = 16] = "Load";
    Intrinsic[Intrinsic["Store"] = 17] = "Store";
    Intrinsic[Intrinsic["Shl"] = 18] = "Shl";
    Intrinsic[Intrinsic["Shr"] = 19] = "Shr";
    Intrinsic[Intrinsic["Or"] = 20] = "Or";
    Intrinsic[Intrinsic["And"] = 21] = "And";
    Intrinsic[Intrinsic["Not"] = 22] = "Not";
    Intrinsic[Intrinsic["Xor"] = 23] = "Xor";
})(Intrinsic || (Intrinsic = {}));
var Keyword;
(function (Keyword) {
    Keyword[Keyword["If"] = 0] = "If";
    Keyword[Keyword["End"] = 1] = "End";
    Keyword[Keyword["Else"] = 2] = "Else";
    Keyword[Keyword["While"] = 3] = "While";
    Keyword[Keyword["IfStar"] = 4] = "IfStar";
})(Keyword || (Keyword = {}));
var OpType;
(function (OpType) {
    OpType[OpType["Intrinsic"] = 0] = "Intrinsic";
    OpType[OpType["Keyword"] = 1] = "Keyword";
    OpType[OpType["PushInt"] = 2] = "PushInt";
    OpType[OpType["SkipFn"] = 3] = "SkipFn";
    OpType[OpType["Ret"] = 4] = "Ret";
    OpType[OpType["Call"] = 5] = "Call";
    OpType[OpType["BindLet"] = 6] = "BindLet";
    OpType[OpType["None"] = 7] = "None";
    OpType[OpType["PushStr"] = 8] = "PushStr";
    OpType[OpType["Javascript"] = 9] = "Javascript";
})(OpType || (OpType = {}));
function printOperation(op) {
    if (op.type === OpType.Call)
        return console.info('Call {name: %s, ip: %d, external: %s}', op.functionName, op.operation, op.externalCall);
    else if (op.type === OpType.Intrinsic)
        return console.info('Intrinsic {%s}', Intrinsic[op.operation]);
    else if (op.type === OpType.Keyword && op.reference !== undefined)
        return console.info('Keyword {%s}', Keyword[op.operation]);
    else if (op.type === OpType.Keyword)
        return console.info('Keyword {%s, %d}', Keyword[op.operation], op.reference);
    else if (op.type === OpType.None)
        return;
    else if (op.type === OpType.PushInt)
        return console.info('PushInt {%d}', op.operation);
    else if (op.type === OpType.PushStr)
        return console.info('PushStr {%s}', String.fromCharCode(...globalThis.__undefieddata__.memory.slice(op.ptr, op.ptr + op.length)));
    else if (op.type === OpType.Ret)
        return console.info('Return');
    else if (op.type === OpType.SkipFn)
        return console.info('SkipFn {%d}', op.operation);
}
// Comment when compiling
// const operations: Operation[] = [
//     {
//         type: OpType.PushInt,
//         operation: 35,
//     },
//     {
//         type: OpType.PushInt,
//         operation: 34,
//     },
//     {
//         type: OpType.Intrinsic,
//         operation: Intrinsic.Plus,
//     },
//     {
//         type: OpType.Intrinsic,
//         operation: Intrinsic.Print,
//     },
//     {
//         type: OpType.None,
//     },
// ];
// Uncomment when compiling
const operations = globalThis.__undefieddata__.operations;
const memory = globalThis.__undefieddata__
    .memory;
const memories = globalThis.__undefieddata__
    .memories;
const run = globalThis.__undefieddata__.run;
const stack = [];
const returnStack = [];
const undefiedProgramExports = globalThis.exports;
for (const e of globalThis.__undefieddata__.exports)
    undefiedProgramExports[e.name] = generateFunction(e.ip, operations);
function resolveFunctionName(name) {
    const split = name.split('.');
    let obj = globalThis;
    for (let i = 0; i < split.length; i++)
        obj = obj?.[split[i]];
    if (obj === undefined || typeof obj !== 'function')
        throw new Error('No function with the name ' + name + ' was found!');
    return obj;
}
let stopRun = false;
globalThis.killCurrentFunction = function killCurrentFunction() {
    stopRun = true;
};
class ExitError extends Error {
    exitCode;
    constructor(exitcode, message) {
        super(message);
        this.exitCode = exitcode;
    }
}
ExitError = globalThis.ExitError;
let firstRun = true;
function interpret(operations, ip, stack) {
    const printExit = firstRun;
    firstRun = false;
    let time = Date.now();
    return new Promise((res, rej) => {
        async function nextInstruction() {
            try {
                let changed = false;
                const op = operations[ip];
                if (!op)
                    throw new ExitError(0, 'No Intructions');
                if (globalThis.devmode && op.type !== OpType.None)
                    printOperation(op);
                if (op.type === OpType.PushInt)
                    stack.push(op.operation);
                else if (op.type === OpType.Intrinsic) {
                    switch (op.operation) {
                        case Intrinsic.Print:
                            console.log(stack.pop()?.toString() + '\n');
                            changed = true;
                            break;
                        case Intrinsic.Plus:
                            stack.push((stack.pop() || 0) + (stack.pop() || 0));
                            break;
                        case Intrinsic.DivMod:
                            {
                                const [top, bottom] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(Math.floor(bottom / top), bottom % top);
                            }
                            break;
                        case Intrinsic.Minus:
                            {
                                const [top, bottom] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(bottom - top);
                            }
                            break;
                        case Intrinsic.Multiply:
                            stack.push((stack.pop() || 0) * (stack.pop() || 0));
                            break;
                        case Intrinsic.Not:
                            stack.push(~(stack.pop() || 0));
                            break;
                        case Intrinsic.Or:
                            stack.push((stack.pop() || 0) | (stack.pop() || 0));
                            break;
                        case Intrinsic.Xor:
                            stack.push((stack.pop() || 0) ^ (stack.pop() || 0));
                            break;
                        case Intrinsic.Shl:
                            {
                                const [top, bottom] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(bottom << top);
                            }
                            break;
                        case Intrinsic.Shr:
                            {
                                const [top, bottom] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(bottom >> top);
                            }
                            break;
                        case Intrinsic.Drop:
                            stack.pop();
                            break;
                        case Intrinsic.Dup:
                            {
                                const val = stack.pop() || 0;
                                stack.push(val, val);
                            }
                            break;
                        case Intrinsic.Equal:
                            stack.push((stack.pop() || 0) === (stack.pop() || 0)
                                ? 1
                                : 0);
                            break;
                        case Intrinsic.NotEqual:
                            stack.push((stack.pop() || 0) !== (stack.pop() || 0)
                                ? 1
                                : 0);
                            break;
                        case Intrinsic.GreaterThan:
                            stack.push((stack.pop() || 0) < (stack.pop() || 0) ? 1 : 0);
                            break;
                        case Intrinsic.GreaterThanEqual:
                            stack.push((stack.pop() || 0) <= (stack.pop() || 0) ? 1 : 0);
                            break;
                        case Intrinsic.LessThan:
                            stack.push((stack.pop() || 0) > (stack.pop() || 0) ? 1 : 0);
                            break;
                        case Intrinsic.LessThanEqual:
                            stack.push((stack.pop() || 0) >= (stack.pop() || 0) ? 1 : 0);
                            break;
                        case Intrinsic.Load:
                            stack.push(memory[stack.pop() || 0]);
                            break;
                        case Intrinsic.Store:
                            {
                                const pointer = stack.pop() || 0;
                                const value = stack.pop() || 0;
                                memory[pointer] = value;
                            }
                            break;
                        case Intrinsic.Over:
                            {
                                const [top, bottom] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(bottom, top, bottom);
                            }
                            break;
                        case Intrinsic.Swap:
                            {
                                const [top, bottom] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(top, bottom);
                            }
                            break;
                        case Intrinsic.Rot:
                            {
                                const [a, b, c] = [
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                    stack.pop() || 0,
                                ];
                                stack.push(a, c, b);
                            }
                            break;
                        default:
                            throw new Error('Unreachable Intrinsic ' + op.operation);
                    }
                }
                else if (op.type === OpType.SkipFn)
                    ip = op.operation - 1;
                else if (op.type === OpType.Ret) {
                    if (op.panic !== undefined) {
                        console.log('\x1B[31m%s\x1B[39m', op.panic);
                        throw new Error(op.panic);
                    }
                    if (returnStack.length > 0)
                        ip = returnStack.pop() || 0;
                    else
                        throw new ExitError(0, 'Return-based exit');
                }
                else if (op.type === OpType.Call) {
                    if (op.externalCall) {
                        changed = true;
                        const fn = resolveFunctionName(op.functionName);
                        const ins = [];
                        for (let i = 0; i < op.ins; i++)
                            ins.push(stack.pop() || 0);
                        const returnValue = await fn(...ins);
                        const outs = returnValue === undefined
                            ? []
                            : returnValue instanceof Array
                                ? returnValue
                                : [returnValue];
                        if (outs.length !== op.outs)
                            throw new Error(op.functionName +
                                ' (external) does not return the desired amount of arguments (returned: ' +
                                outs.length +
                                ', desired: ' +
                                op.outs +
                                ')');
                        stack.push(...outs);
                    }
                    else {
                        returnStack.push(ip);
                        ip = op.operation - 1;
                    }
                }
                else if (op.type === OpType.Keyword) {
                    switch (op.operation) {
                        case Keyword.End:
                            if (op.reference)
                                ip = op.reference - 1;
                            break;
                        case Keyword.Else:
                            ip = (op.reference || 1) - 1;
                            break;
                        case Keyword.If:
                        case Keyword.IfStar:
                            if ((stack.pop() || 0) < 1)
                                ip = (op.reference || 1) - 1;
                            break;
                        case Keyword.While:
                            {
                                const val = stack.pop() || 0;
                                stack.push(val);
                                if (val < 1)
                                    ip = (op.reference || 1) - 1;
                            }
                            break;
                        default:
                            throw new Error('Unreachable (keywords)');
                    }
                }
                else if (op.type === OpType.None) {
                }
                else if (op.type === OpType.PushStr)
                    stack.push(op.length, op.ptr);
                else if (op.type === OpType.Javascript) {
                    try {
                        await eval(op.value)(stack);
                    }
                    catch (e) {
                        console.error('\x1B[31mThe following Error occured in a javascript code-snippet:\n');
                        console.error(e);
                        console.error('\x1B[39m\n');
                        console.log('Code Snippet:\n', op.value
                            .split('\n')
                            .map((el) => ' >  ' + el)
                            .join('\n'), '\n');
                        throw e;
                    }
                }
                else
                    throw new Error('Unreachable (optype)');
            }
            catch (e) {
                await globalThis.awaitNextRender();
                if (printExit) {
                    if (!e || !(e instanceof ExitError)) {
                        console.error('\n\x1B[31m[Program exited with -1: SYSERR]\n');
                        console.error(e, '\x1B[39m');
                        return rej(e);
                    }
                    else {
                        if (e.exitCode === 0) {
                            if (e.message.length > 0)
                                console.log('\n[Program exited with 0: %s]', e.message);
                            else
                                console.log('\n[Program exited with 0]');
                        }
                        else {
                            if (e.message.length > 0)
                                console.error('\n\x1B[31m[Program exited with %d: %s]\x1B[39m', e.exitCode, e.message);
                            else
                                console.error('\n\x1B[31m[Program exited with %d]\x1B[39m', e.exitCode);
                        }
                    }
                    return res(stack);
                }
                else {
                    if (!e || !(e instanceof ExitError))
                        return rej(e);
                    else
                        return res(stack);
                }
                return rej(e);
            }
            ip++;
            if (stopRun) {
                stopRun = false;
                await globalThis.awaitNextRender();
                if (printExit) {
                    console.error('\n\x1B[31m[Program exited with -1: SIGKILL]\n\x1B[39m');
                }
                return rej(new ExitError(1, 'SIGKILL'));
            }
            else if (Date.now() - time > 16)
                requestAnimationFrame(nextInstruction);
            else
                return await nextInstruction();
        }
        nextInstruction();
    }).then((value) => !globalThis.process
        ? globalThis.awaitNextRender().then(() => value)
        : value);
}
function generateFunction(ip, operations) {
    return (...stack) => interpret(operations, ip, [...stack].reverse());
}
globalThis.__undefiedinterpreter__ = {
    interpret,
    generateFunction,
    operations,
};
(async function () {
    for (const r of run)
        await interpret(operations, r, []);
    if (globalThis.__undefieddata__.mainop !== -1)
        // dont run when mainop is -1, as then nomain is set
        await interpret(operations, globalThis.__undefieddata__.mainop, stack);
})();


// Event Listeners

}
(window.requestAnimationFrame || ((fn) => setTimeout(fn, 50)))(runUndefiedCode, 50);</script></body></html>